"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageList = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _Message = require("./Message");

var _context2 = require("../context");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _EmptyStateIndicator = require("./EmptyStateIndicator");

var _ReverseInfiniteScroll = require("./ReverseInfiniteScroll");

var _MessageNotification = require("./MessageNotification");

var _MessageSimple = require("./MessageSimple");

var _Attachment = require("./Attachment");

var _LoadingIndicator = require("./LoadingIndicator");

var _DateSeparator = require("./DateSeparator");

var _EventComponent = require("./EventComponent");

var _AutoCompleteTextarea = require("./AutoCompleteTextarea");

var _deepEqual = _interopRequireDefault(require("deep-equal"));

var _utils = require("../utils");

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var MessageList = function (_PureComponent) {
  (0, _inherits2.default)(MessageList, _PureComponent);

  var _super = _createSuper(MessageList);

  function MessageList(props) {
    var _this;

    (0, _classCallCheck2.default)(this, MessageList);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "connectionChanged", function (event) {
      if (_this.state.online !== event.online) {
        _this.setState({
          online: event.online
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "keypress", function (event) {
      if (event.keyCode === _AutoCompleteTextarea.KEY_CODES.ESC && _this.state.editing) {
        _this.clearEditingState();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollToBottom", function () {
      _this._scrollToRef(_this.bottomRef, _this.messageList);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_scrollToRef", function (el, parent) {
      function scrollDown() {
        if (el && el.current && parent && parent.current) {
          this.scrollToTarget(el.current, parent.current);
        }
      }

      scrollDown.call((0, _assertThisInitialized2.default)(_this));
      setTimeout(scrollDown.bind((0, _assertThisInitialized2.default)(_this)), 200);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollToTarget", function (target, containerEl) {
      var isElement = target && target.nodeType === 1,
          isNumber = Object.prototype.toString.call(target) === '[object Number]';

      if (isElement) {
        containerEl.scrollTop = target.offsetTop;
      } else if (isNumber) {
        containerEl.scrollTop = target;
      } else if (target === 'bottom') {
        containerEl.scrollTop = containerEl.scrollHeight - containerEl.offsetHeight;
      } else if (target === 'top') {
        containerEl.scrollTop = 0;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setEditingState", function (message) {
      _this.setState({
        editing: message.id
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "clearEditingState", function (e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      _this.setState({
        editing: ''
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "insertDates", function (messages) {
      var newMessages = [];

      var _iterator = _createForOfIteratorHelper(messages.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
              i = _step$value[0],
              message = _step$value[1];

          if (message.type === 'message.read') {
            newMessages.push(message);
            continue;
          }

          var messageDate = message.created_at.toDateString();
          var prevMessageDate = messageDate;

          if (i > 0) {
            prevMessageDate = messages[i - 1].created_at.toDateString();
          }

          if (i === 0 || messageDate !== prevMessageDate) {
            newMessages.push({
              type: 'message.date',
              date: message.created_at
            }, message);
          } else {
            newMessages.push(message);
          }

          var eventsNextToMessage = _this.props.eventHistory[message.id || 'first'];

          if (eventsNextToMessage && eventsNextToMessage.length > 0) {
            eventsNextToMessage.forEach(function (e) {
              newMessages.push({
                type: 'channel.event',
                event: e
              });
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return newMessages;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "insertIntro", function (messages) {
      var newMessages = messages || [];

      if (!_this.props.headerPosition) {
        newMessages.unshift({
          type: 'channel.intro'
        });
        return newMessages;
      }

      if (!newMessages.length) {
        newMessages.unshift({
          type: 'channel.intro'
        });
        return newMessages;
      }

      var _iterator2 = _createForOfIteratorHelper(messages.entries()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              i = _step2$value[0],
              message = _step2$value[1];

          var messageTime = message.created_at ? message.created_at.getTime() : null;
          var nextMessageTime = messages[i + 1] && messages[i + 1].created_at ? messages[i + 1].created_at.getTime() : null;
          var headerPosition = _this.props.headerPosition;

          if (messageTime < headerPosition) {
            if (nextMessageTime < headerPosition) {
              if (messages[i + 1] && messages[i + 1].type === 'message.date') continue;

              if (!nextMessageTime) {
                newMessages.push({
                  type: 'channel.intro'
                });
                return newMessages;
              }

              continue;
            } else {
              newMessages.splice(i + 1, 0, {
                type: 'channel.intro'
              });
              return newMessages;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return newMessages;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "goToNewMessages", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.scrollToBottom();

            case 2:
              _this.setState({
                newMessagesNotification: false
              });

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getReadStates", function (messages) {
      var readData = {};

      var _iterator3 = _createForOfIteratorHelper(messages),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var message = _step3.value;
          readData[message.id] = [];
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      for (var _i = 0, _Object$values = Object.values(_this.props.read); _i < _Object$values.length; _i++) {
        var readState = _Object$values[_i];

        if (readState.last_read == null) {
          break;
        }

        var userLastReadMsgId = void 0;

        var _iterator4 = _createForOfIteratorHelper(messages),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var msg = _step4.value;

            if (msg.updated_at < readState.last_read) {
              userLastReadMsgId = msg.id;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (userLastReadMsgId != null) {
          readData[userLastReadMsgId] = [].concat((0, _toConsumableArray2.default)(readData[userLastReadMsgId]), [readState.user]);
        }
      }

      return readData;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "userScrolledUp", function () {
      return _this.scrollOffset > 310;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "listenToScroll", function (offset) {
      _this.scrollOffset = offset;

      if (_this.state.newMessagesNotification && !_this.userScrolledUp()) {
        _this.setState({
          newMessagesNotification: false
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getLastReceived", function (messages) {
      var l = messages.length;
      var lastReceivedId = null;

      for (var i = l; i > 0; i--) {
        if (messages[i] !== undefined && messages[i].status !== undefined && messages[i].status === 'received') {
          lastReceivedId = messages[i].id;
          break;
        }
      }

      return lastReceivedId;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getGroupStyles", function (m) {
      var l = m.length;
      var messageGroupStyles = {};
      var messages = (0, _toConsumableArray2.default)(m);

      for (var i = 0; i < l; i++) {
        var previousMessage = messages[i - 1];
        var message = messages[i];
        var nextMessage = messages[i + 1];
        var groupStyles = [];

        if (message.type === 'message.date') {
          continue;
        }

        if (message.type === 'channel.event') {
          continue;
        }

        if (message.type === 'channel.intro') {
          continue;
        }

        var userId = message.user.id;
        var isTopMessage = !previousMessage || previousMessage.type === 'channel.intro' || previousMessage.type === 'message.date' || previousMessage.type === 'system' || previousMessage.type === 'channel.event' || previousMessage.attachments.length !== 0 || userId !== previousMessage.user.id || previousMessage.type === 'error' || previousMessage.deleted_at;
        var isBottomMessage = !nextMessage || nextMessage.type === 'message.date' || nextMessage.type === 'system' || nextMessage.type === 'channel.event' || nextMessage.type === 'channel.intro' || nextMessage.attachments.length !== 0 || userId !== nextMessage.user.id || nextMessage.type === 'error' || nextMessage.deleted_at;

        if (isTopMessage) {
          groupStyles.push('top');
        }

        if (isBottomMessage) {
          if (isTopMessage || message.deleted_at || message.type === 'error') {
            groupStyles.splice(0, groupStyles.length);
            groupStyles.push('single');
          } else {
            groupStyles.push('bottom');
          }
        }

        if (!isTopMessage && !isBottomMessage) {
          if (message.deleted_at || message.type === 'error') {
            groupStyles.splice(0, groupStyles.length);
            groupStyles.push('single');
          } else {
            groupStyles.splice(0, groupStyles.length);
            groupStyles.push('middle');
          }
        }

        if (message.attachments.length !== 0) {
          groupStyles.splice(0, groupStyles.length);
          groupStyles.push('single');
        }

        if (_this.props.noGroupByUser) {
          groupStyles.splice(0, groupStyles.length);
          groupStyles.push('single');
        }

        messageGroupStyles[message.id] = groupStyles;
      }

      return messageGroupStyles;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onMentionsHoverOrClick", function (e, mentioned_users) {
      if (!_this.props.onMentionsHover || !_this.props.onMentionsClick) return;
      var tagName = e.target.tagName.toLowerCase();
      var textContent = e.target.innerHTML.replace('*', '');

      if (tagName === 'strong' && textContent[0] === '@') {
        var userName = textContent.replace('@', '');
        var user = mentioned_users.find(function (user) {
          return user.name === userName || user.id === userName;
        });

        if (_this.props.onMentionsHover && e.type === 'mouseover') {
          _this.props.onMentionsHover(e, user);
        }

        if (_this.props.onMentionsClick && e.type === 'click') {
          _this.props.onMentionsHover(e, user);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "addNotification", function (notificationText, type) {
      if (typeof notificationText !== 'string') return;
      if (type !== 'success' && type !== 'error') return;
      var nextIndex = new Date();
      var newNotifications = (0, _toConsumableArray2.default)(_this.state.notifications);
      newNotifications.push({
        id: nextIndex,
        text: notificationText,
        type
      });

      _this.setState({
        notifications: newNotifications
      });

      var ct = setTimeout(function () {
        var index = _this.state.notifications.findIndex(function (notification) {
          if (notification.id === nextIndex) return true;
          return false;
        });

        var newNotifications = (0, _toConsumableArray2.default)(_this.state.notifications);
        newNotifications.splice(index, 1);

        _this.setState({
          notifications: newNotifications
        });
      }, 5000);

      _this.notificationTimeouts.push(ct);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_loadMore", function () {
      return _this.props.messageLimit ? _this.props.loadMore(_this.props.messageLimit) : _this.props.loadMore();
    });
    _this.state = {
      newMessagesNotification: false,
      editing: '',
      online: true,
      notifications: []
    };
    _this.bottomRef = _react.default.createRef();
    _this.messageList = _react.default.createRef();
    _this.messageRefs = {};
    _this.notificationTimeouts = [];
    return _this;
  }

  (0, _createClass2.default)(MessageList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToBottom();
      var messageListRect = this.messageList.current.getBoundingClientRect();
      this.setState({
        messageListRect
      });
      this.props.client.on('connection.changed', this.connectionChanged);
      document.addEventListener('keydown', this.keypress);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.props.client.off('connection.changed', this.connectionChanged);
      document.removeEventListener('keydown', this.keypress);
      this.notificationTimeouts.forEach(function (ct) {
        clearTimeout(ct);
      });
    }
  }, {
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate(prevProps) {
      if (this.props.threadList) {
        return null;
      }

      if (prevProps.messages.length < this.props.messages.length || !(0, _deepEqual.default)(this.props.eventHistory, prevProps.eventHistory)) {
        var list = this.messageList.current;
        return {
          offsetTop: list.scrollTop,
          offsetBottom: list.scrollHeight - list.scrollTop
        };
      }

      return null;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      var userScrolledUp = this.userScrolledUp();
      var currentLastMessage = this.props.messages[this.props.messages.length - 1];
      var previousLastMessage = prevProps.messages[prevProps.messages.length - 1];

      if (!previousLastMessage || !currentLastMessage) {
        return;
      }

      var hasNewMessage = currentLastMessage.id !== previousLastMessage.id;
      var isOwner = currentLastMessage.user.id === this.props.client.userID;
      var list = this.messageList.current;
      var scrollToBottom = hasNewMessage && (isOwner || !userScrolledUp);

      if (scrollToBottom) {
        this.scrollToBottom();
        setTimeout(this.scrollToBottom, 100);
        this.state.newMessagesNotification && this.setState({
          newMessagesNotification: false
        });
        return;
      }

      if (snapshot !== null) {
        if (hasNewMessage) {
          this.scrollToTarget(snapshot.offsetTop, this.messageList.current);
        } else {
          this.scrollToTarget(list.scrollHeight - snapshot.offsetBottom, this.messageList.current);
        }
      }

      if (hasNewMessage && !this.state.newMessagesNotification) {
        this.setState({
          newMessagesNotification: true
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var allMessages = (0, _toConsumableArray2.default)(this.props.messages);
      var MessageSystem = this.props.MessageSystem;
      allMessages = this.insertDates(allMessages);

      if (this.props.HeaderComponent) {
        allMessages = this.insertIntro(allMessages);
      }

      var messageGroupStyles = this.getGroupStyles(allMessages);
      var _this$props = this.props,
          TypingIndicator = _this$props.TypingIndicator,
          DateSeparator = _this$props.dateSeparator,
          HeaderComponent = _this$props.HeaderComponent,
          EmptyStateIndicator = _this$props.EmptyStateIndicator,
          t = _this$props.t;
      allMessages.sort(function (a, b) {
        return a.created_at - b.created_at;
      });
      var readData = this.getReadStates(allMessages);
      var lastReceivedId = this.getLastReceived(allMessages);
      var elements = [];

      var _iterator5 = _createForOfIteratorHelper(allMessages),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var message = _step5.value;

          if (message.id) {
            this.messageRefs[message.id] = _react.default.createRef();
          }

          if (message.type === 'message.date') {
            if (this.props.threadList) {
              continue;
            }

            elements.push(_react.default.createElement("li", {
              key: message.date.toISOString() + '-i'
            }, _react.default.createElement(DateSeparator, {
              date: message.date
            })));
          } else if (message.type === 'channel.intro') {
            elements.push(_react.default.createElement("li", {
              key: "intro"
            }, _react.default.createElement(HeaderComponent, null)));
          } else if (message.type === 'channel.event' || message.type === 'system') {
            MessageSystem && elements.push(_react.default.createElement("li", {
              key: message.type === 'system' ? message.created_at : message.type === 'channel.event' ? message.event.created_at : ''
            }, _react.default.createElement(MessageSystem, {
              message: message
            })));
          } else if (message.type !== 'message.read') {
            var groupStyles = messageGroupStyles[message.id];

            if (!groupStyles) {
              groupStyles = [];
            }

            var readBy = readData[message.id] || [];
            elements.push(_react.default.createElement("li", {
              className: "str-chat__li str-chat__li--".concat(groupStyles),
              key: message.id || message.created_at,
              ref: this.messageRefs[message.id]
            }, _react.default.createElement(_Message.Message, {
              client: this.props.client,
              openThread: this.props.openThread,
              members: this.props.members,
              watchers: this.props.watchers,
              message: message,
              groupStyles: groupStyles,
              readBy: readBy,
              lastReceivedId: lastReceivedId === message.id ? lastReceivedId : null,
              editing: !!(this.state.editing && this.state.editing === message.id),
              clearEditingState: this.clearEditingState,
              setEditingState: this.setEditingState,
              messageListRect: this.state.messageListRect,
              channel: this.props.channel,
              threadList: this.props.threadList,
              retrySendMessage: this.props.retrySendMessage,
              addNotification: this.addNotification,
              updateMessage: this.props.updateMessage,
              removeMessage: this.props.removeMessage,
              Message: this.props.Message,
              unsafeHTML: this.props.unsafeHTML,
              Attachment: this.props.Attachment,
              onMentionsClick: this.props.onMentionsClick,
              onMentionsHover: this.props.onMentionsHover,
              messageActions: this.props.messageActions,
              additionalMessageInputProps: this.props.additionalMessageInputProps,
              getFlagMessageSuccessNotification: this.props.getFlagMessageSuccessNotification,
              getFlagMessageErrorNotification: this.props.getFlagMessageErrorNotification,
              getMuteUserSuccessNotification: this.props.getMuteUserSuccessNotification,
              getMuteUserErrorNotification: this.props.getMuteUserErrorNotification
            })));
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("div", {
        className: "str-chat__list ".concat(this.props.threadList ? 'str-chat__list--thread' : ''),
        ref: this.messageList
      }, !elements.length ? _react.default.createElement(EmptyStateIndicator, {
        listType: "message"
      }) : _react.default.createElement(_ReverseInfiniteScroll.ReverseInfiniteScroll, {
        loadMore: this._loadMore,
        hasMore: this.props.hasMore,
        isLoading: this.props.loadingMore,
        listenToScroll: this.listenToScroll,
        useWindow: false,
        loader: _react.default.createElement(Center, {
          key: "loadingindicator"
        }, _react.default.createElement(_LoadingIndicator.LoadingIndicator, {
          size: 20
        }))
      }, _react.default.createElement("ul", {
        className: "str-chat__ul"
      }, elements), this.props.TypingIndicator && _react.default.createElement(TypingIndicator, {
        typing: this.props.typing,
        client: this.props.client
      }), _react.default.createElement("div", {
        key: "bottom",
        ref: this.bottomRef
      }))), _react.default.createElement("div", {
        className: "str-chat__list-notifications"
      }, this.state.notifications.map(function (notification) {
        return _react.default.createElement(Notification, {
          active: true,
          key: notification.id,
          type: notification.type
        }, notification.text);
      }), _react.default.createElement(Notification, {
        active: !this.state.online,
        type: "error"
      }, t('Connection failure, reconnecting now...')), _react.default.createElement(_MessageNotification.MessageNotification, {
        showNotification: this.state.newMessagesNotification,
        onClick: function onClick() {
          return _this2.goToNewMessages();
        }
      }, t('New Messages!'))));
    }
  }]);
  return MessageList;
}(_react.PureComponent);

exports.MessageList = MessageList;
(0, _defineProperty2.default)(MessageList, "propTypes", {
  TypingIndicator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  dateSeparator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  noGroupByUser: _propTypes.default.bool,
  unsafeHTML: _propTypes.default.bool,
  messageLimit: _propTypes.default.number,
  messageActions: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.array]),
  threadList: _propTypes.default.bool,
  getFlagMessageSuccessNotification: _propTypes.default.func,
  getFlagMessageErrorNotification: _propTypes.default.func,
  getMuteUserSuccessNotification: _propTypes.default.func,
  getMuteUserErrorNotification: _propTypes.default.func,
  client: _propTypes.default.object,
  Attachment: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  Message: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  MessageSystem: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  EmptyStateIndicator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  HeaderComponent: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  messages: _propTypes.default.array.isRequired,
  channel: _propTypes.default.object.isRequired,
  updateMessage: _propTypes.default.func.isRequired,
  retrySendMessage: _propTypes.default.func,
  removeMessage: _propTypes.default.func,
  onMentionsClick: _propTypes.default.func,
  onMentionsHover: _propTypes.default.func,
  openThread: _propTypes.default.func,
  members: _propTypes.default.object,
  watchers: _propTypes.default.object,
  read: _propTypes.default.object,
  typing: _propTypes.default.object,
  additionalMessageInputProps: _propTypes.default.object
});
(0, _defineProperty2.default)(MessageList, "defaultProps", {
  Message: _MessageSimple.MessageSimple,
  MessageSystem: _EventComponent.EventComponent,
  threadList: false,
  Attachment: _Attachment.Attachment,
  dateSeparator: _DateSeparator.DateSeparator,
  EmptyStateIndicator: _EmptyStateIndicator.EmptyStateIndicator,
  unsafeHTML: false,
  noGroupByUser: false,
  messageActions: Object.keys(_utils.MESSAGE_ACTIONS)
});
exports.MessageList = MessageList = (0, _context2.withChannelContext)((0, _context2.withTranslationContext)(MessageList));

var Center = function Center(_ref2) {
  var children = _ref2.children;
  return _react.default.createElement("div", {
    className: "str-chat__list__center"
  }, children);
};

var Notification = function Notification(_ref3) {
  var children = _ref3.children,
      active = _ref3.active,
      type = _ref3.type;

  if (active) {
    return _react.default.createElement("div", {
      className: "str-chat__custom-notification notification-".concat(type)
    }, children);
  }

  return null;
};