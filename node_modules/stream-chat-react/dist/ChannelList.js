"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChannelList = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _seamlessImmutable = _interopRequireDefault(require("seamless-immutable"));

var _utils = require("../utils");

var _ChannelPreviewLastMessage = require("./ChannelPreviewLastMessage");

var _ChannelPreview = require("./ChannelPreview");

var _EmptyStateIndicator = require("./EmptyStateIndicator");

var _LoadingChannels = require("./LoadingChannels");

var _LoadMorePaginator = require("./LoadMorePaginator");

var _context6 = require("../context");

var _ChannelListTeam = require("./ChannelListTeam");

var _lodash = _interopRequireDefault(require("lodash.uniqby"));

var _deepEqual = _interopRequireDefault(require("deep-equal"));

var _ChatDown = require("./ChatDown");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var ChannelList = function (_PureComponent) {
  (0, _inherits2.default)(ChannelList, _PureComponent);

  var _super = _createSuper(ChannelList);

  function ChannelList(_props) {
    var _this;

    (0, _classCallCheck2.default)(this, ChannelList);
    _this = _super.call(this, _props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "queryChannels", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
      var _this$props, options, filters, sort, setActiveChannelOnMount, offset, newOptions, channelPromise, channelQueryResponse, customActiveChannel;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$props = _this.props, options = _this$props.options, filters = _this$props.filters, sort = _this$props.sort, setActiveChannelOnMount = _this$props.setActiveChannelOnMount;
              offset = _this.state.offset;

              _this.setState({
                refreshing: true
              });

              newOptions = _objectSpread({}, options);
              if (!options.limit) newOptions.limit = 30;
              channelPromise = _this.props.client.queryChannels(filters, sort, _objectSpread({}, newOptions, {
                offset
              }));
              _context.prev = 6;
              channelQueryResponse = channelPromise;

              if (!(0, _utils.isPromise)(channelQueryResponse)) {
                _context.next = 12;
                break;
              }

              _context.next = 11;
              return channelPromise;

            case 11:
              channelQueryResponse = _context.sent;

            case 12:
              _this.setState(function (prevState) {
                var channels = [].concat((0, _toConsumableArray2.default)(prevState.channels), (0, _toConsumableArray2.default)(channelQueryResponse));
                return {
                  channels,
                  loadingChannels: false,
                  offset: channels.length,
                  hasNextPage: channelQueryResponse.length >= newOptions.limit ? true : false,
                  refreshing: false
                };
              });

              if (_this.props.customActiveChannel) {
                customActiveChannel = channelQueryResponse.filter(function (channel) {
                  return channel.id === _this.props.customActiveChannel;
                })[0];

                if (customActiveChannel) {
                  _this.props.setActiveChannel(customActiveChannel, _this.props.watchers);

                  _this.moveChannelUp(customActiveChannel.cid);
                }
              } else if (setActiveChannelOnMount && offset === 0 && _this.state.channels.length) {
                _this.props.setActiveChannel(_this.state.channels[0], _this.props.watchers);
              }

              _context.next = 20;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](6);
              console.warn(_context.t0);

              _this.setState({
                error: true,
                refreshing: false
              });

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 16]]);
    })));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleEvent", function () {
      var _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(e) {
        var newChannels, channel, _channel, channels, channelIndex, _channels, _channelIndex;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (e.type === 'user.presence.changed') {
                  newChannels = _this.state.channels;
                  newChannels = newChannels.map(function (channel) {
                    if (!channel.state.members[e.user.id]) return channel;
                    channel.state.members.setIn([e.user.id, 'user'], e.user);
                    return channel;
                  });

                  _this.setState({
                    channels: (0, _toConsumableArray2.default)(newChannels)
                  });
                }

                if (e.type === 'message.new') {
                  !_this.props.lockChannelOrder && _this.moveChannelUp(e.cid);
                }

                if (e.type === 'connection.recovered') {
                  _this.setState(function (prevState) {
                    return {
                      connectionRecoveredCount: prevState.connectionRecoveredCount + 1
                    };
                  });
                }

                if (!(e.type === 'notification.message_new')) {
                  _context2.next = 12;
                  break;
                }

                if (!(_this.props.onMessageNew && typeof _this.props.onMessageNew === 'function')) {
                  _context2.next = 8;
                  break;
                }

                _this.props.onMessageNew((0, _assertThisInitialized2.default)(_this), e);

                _context2.next = 12;
                break;

              case 8:
                _context2.next = 10;
                return _this.getChannel(e.channel.type, e.channel.id);

              case 10:
                channel = _context2.sent;

                _this.setState(function (prevState) {
                  return {
                    channels: (0, _lodash.default)([channel].concat((0, _toConsumableArray2.default)(prevState.channels)), 'cid')
                  };
                });

              case 12:
                if (!(e.type === 'notification.added_to_channel')) {
                  _context2.next = 21;
                  break;
                }

                if (!(_this.props.onAddedToChannel && typeof _this.props.onAddedToChannel === 'function')) {
                  _context2.next = 17;
                  break;
                }

                _this.props.onAddedToChannel((0, _assertThisInitialized2.default)(_this), e);

                _context2.next = 21;
                break;

              case 17:
                _context2.next = 19;
                return _this.getChannel(e.channel.type, e.channel.id);

              case 19:
                _channel = _context2.sent;

                _this.setState(function (prevState) {
                  return {
                    channels: (0, _lodash.default)([_channel].concat((0, _toConsumableArray2.default)(prevState.channels)), 'cid')
                  };
                });

              case 21:
                if (e.type === 'notification.removed_from_channel') {
                  if (_this.props.onRemovedFromChannel && typeof _this.props.onRemovedFromChannel === 'function') {
                    _this.props.onRemovedFromChannel((0, _assertThisInitialized2.default)(_this), e);
                  } else {
                    _this.setState(function (prevState) {
                      var channels = prevState.channels.filter(function (channel) {
                        return channel.cid !== e.channel.cid;
                      });
                      return {
                        channels
                      };
                    });
                  }
                }

                if (e.type === 'channel.updated') {
                  channels = _this.state.channels;
                  channelIndex = channels.findIndex(function (channel) {
                    return channel.cid === e.channel.cid;
                  });

                  if (channelIndex > -1) {
                    channels[channelIndex].data = (0, _seamlessImmutable.default)(e.channel);

                    _this.setState({
                      channels: (0, _toConsumableArray2.default)(channels),
                      channelUpdateCount: _this.state.channelUpdateCount + 1
                    });
                  }

                  if (_this.props.onChannelUpdated && typeof _this.props.onChannelUpdated === 'function') {
                    _this.props.onChannelUpdated((0, _assertThisInitialized2.default)(_this), e);
                  }
                }

                if (!(e.type === 'channel.deleted')) {
                  _context2.next = 34;
                  break;
                }

                if (!(_this.props.onChannelDeleted && typeof _this.props.onChannelDeleted === 'function')) {
                  _context2.next = 28;
                  break;
                }

                _this.props.onChannelDeleted((0, _assertThisInitialized2.default)(_this), e);

                _context2.next = 34;
                break;

              case 28:
                _channels = _this.state.channels;
                _channelIndex = _channels.findIndex(function (channel) {
                  return channel.cid === e.channel.cid;
                });

                if (!(_channelIndex < 0)) {
                  _context2.next = 32;
                  break;
                }

                return _context2.abrupt("return");

              case 32:
                _channels.splice(_channelIndex, 1);

                _this.setState({
                  channels: (0, _toConsumableArray2.default)(_channels),
                  channelUpdateCount: _this.state.channelUpdateCount + 1
                });

              case 34:
                if (e.type === 'channel.truncated') {
                  _this.setState(function (prevState) {
                    return {
                      channels: (0, _toConsumableArray2.default)(prevState.channels),
                      channelUpdateCount: prevState.channelUpdateCount + 1
                    };
                  });

                  if (_this.props.onChannelTruncated && typeof _this.props.onChannelTruncated === 'function') _this.props.onChannelTruncated((0, _assertThisInitialized2.default)(_this), e);
                }

                return _context2.abrupt("return", null);

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getChannel", function () {
      var _ref3 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(type, id) {
        var channel;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                channel = _this.props.client.channel(type, id);
                _context3.next = 3;
                return channel.watch();

              case 3:
                return _context3.abrupt("return", channel);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "moveChannelUp", function (cid) {
      var channels = _this.state.channels;

      var channelIndex = _this.state.channels.findIndex(function (channel) {
        return channel.cid === cid;
      });

      if (channelIndex <= 0) return;
      var channel = channels[channelIndex];
      channels.splice(channelIndex, 1);
      channels.unshift(channel);

      _this.setState({
        channels: (0, _toConsumableArray2.default)(channels)
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "loadNextPage", function () {
      _this.queryChannels();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_renderChannel", function (item) {
      var _this$props2 = _this.props,
          Preview = _this$props2.Preview,
          setActiveChannel = _this$props2.setActiveChannel,
          channel = _this$props2.channel,
          watchers = _this$props2.watchers;
      if (!item) return;
      var props = {
        channel: item,
        activeChannel: channel,
        Preview,
        setActiveChannel,
        watchers,
        key: item.id,
        channelUpdateCount: _this.state.channelUpdateCount,
        connectionRecoveredCount: _this.state.connectionRecoveredCount
      };
      return (0, _utils.smartRender)(_ChannelPreview.ChannelPreview, _objectSpread({}, props));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_handleClickOutside", function (e) {
      if (_this.channelListRef && !_this.channelListRef.contains(e.target) && _this.props.navOpen) {
        _this.props.closeMobileNav();
      }
    });
    _this.state = {
      channels: (0, _seamlessImmutable.default)([]),
      loadingChannels: true,
      refreshing: false,
      hasNextPage: false,
      offset: 0,
      error: false,
      connectionRecoveredCount: 0,
      channelUpdateCount: 0
    };
    _this.menuButton = _react.default.createRef();
    return _this;
  }

  (0, _createClass2.default)(ChannelList, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error, info) {
      console.warn(error, info);
    }
  }, {
    key: "componentDidMount",
    value: function () {
      var _componentDidMount = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.queryChannels();

              case 2:
                document.addEventListener('click', this._handleClickOutside);
                this.listenToChanges();

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function componentDidMount() {
        return _componentDidMount.apply(this, arguments);
      }

      return componentDidMount;
    }()
  }, {
    key: "componentDidUpdate",
    value: function () {
      var _componentDidUpdate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(prevProps) {
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if ((0, _deepEqual.default)(prevProps.filters, this.props.filters)) {
                  _context5.next = 5;
                  break;
                }

                _context5.next = 3;
                return this.setState({
                  offset: 0,
                  channels: (0, _seamlessImmutable.default)([]),
                  loadingChannels: true,
                  refreshing: false
                });

              case 3:
                _context5.next = 5;
                return this.queryChannels();

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function componentDidUpdate(_x4) {
        return _componentDidUpdate.apply(this, arguments);
      }

      return componentDidUpdate;
    }()
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('click', this._handleClickOutside);
      this.props.client.off(this.handleEvent);
    }
  }, {
    key: "listenToChanges",
    value: function listenToChanges() {
      this.props.client.on(this.handleEvent);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          List = _this$props3.List,
          Paginator = _this$props3.Paginator,
          EmptyStateIndicator = _this$props3.EmptyStateIndicator;
      var _this$state = this.state,
          channels = _this$state.channels,
          loadingChannels = _this$state.loadingChannels,
          refreshing = _this$state.refreshing,
          hasNextPage = _this$state.hasNextPage;
      return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("div", {
        className: "str-chat str-chat-channel-list ".concat(this.props.theme, " ").concat(this.props.navOpen ? 'str-chat-channel-list--open' : ''),
        ref: function ref(_ref4) {
          return _this2.channelListRef = _ref4;
        }
      }, _react.default.createElement(List, {
        loading: loadingChannels,
        error: this.state.error,
        channels: channels,
        setActiveChannel: this.props.setActiveChannel,
        activeChannel: this.props.channel,
        showSidebar: this.props.showSidebar,
        LoadingIndicator: this.props.LoadingIndicator,
        LoadingErrorIndicator: this.props.LoadingErrorIndicator
      }, !channels.length ? _react.default.createElement(EmptyStateIndicator, {
        listType: "channel"
      }) : (0, _utils.smartRender)(Paginator, {
        loadNextPage: this.loadNextPage,
        hasNextPage,
        refreshing,
        children: channels.map(function (item) {
          return _this2._renderChannel(item);
        })
      }))));
    }
  }], [{
    key: "getDerivedStateFromError",
    value: function getDerivedStateFromError() {
      return {
        error: true
      };
    }
  }]);
  return ChannelList;
}(_react.PureComponent);

exports.ChannelList = ChannelList;
(0, _defineProperty2.default)(ChannelList, "propTypes", {
  EmptyStateIndicator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  Preview: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  LoadingIndicator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  LoadingErrorIndicator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  List: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  Paginator: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  onMessageNew: _propTypes.default.func,
  onAddedToChannel: _propTypes.default.func,
  onRemovedFromChannel: _propTypes.default.func,
  onChannelUpdated: _propTypes.default.func,
  onChannelTruncated: _propTypes.default.func,
  onChannelDeleted: _propTypes.default.func,
  filters: _propTypes.default.object,
  options: _propTypes.default.object,
  sort: _propTypes.default.object,
  watchers: _propTypes.default.object,
  customAciveChannel: _propTypes.default.string,
  setActiveChannelOnMount: _propTypes.default.bool,
  lockChannelOrder: _propTypes.default.bool
});
(0, _defineProperty2.default)(ChannelList, "defaultProps", {
  Preview: _ChannelPreviewLastMessage.ChannelPreviewLastMessage,
  LoadingIndicator: _LoadingChannels.LoadingChannels,
  LoadingErrorIndicator: _ChatDown.ChatDown,
  List: _ChannelListTeam.ChannelListTeam,
  Paginator: _LoadMorePaginator.LoadMorePaginator,
  EmptyStateIndicator: _EmptyStateIndicator.EmptyStateIndicator,
  setActiveChannelOnMount: true,
  filters: {},
  options: {},
  sort: {},
  watchers: {}
});
exports.ChannelList = ChannelList = (0, _context6.withChatContext)(ChannelList);