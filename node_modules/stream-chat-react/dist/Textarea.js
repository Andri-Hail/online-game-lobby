"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _textareaCaret = _interopRequireDefault(require("textarea-caret"));

var _customEvent = _interopRequireDefault(require("custom-event"));

var _listener = _interopRequireWildcard(require("./listener"));

var _List = _interopRequireDefault(require("./List"));

var _utils = require("./utils");

var _reactTextareaAutosize = _interopRequireDefault(require("react-textarea-autosize"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DEFAULT_CARET_POSITION = 'next';

var errorMessage = function errorMessage(message) {
  return console.error("RTA: dataProvider fails: ".concat(message, "\n    \nCheck the documentation or create issue if you think it's bug. https://github.com/webscopeio/react-textarea-autocomplete/issues"));
};

var ReactTextareaAutocomplete = function (_React$Component) {
  (0, _inherits2.default)(ReactTextareaAutocomplete, _React$Component);

  var _super = _createSuper(ReactTextareaAutocomplete);

  function ReactTextareaAutocomplete(_props) {
    var _this;

    (0, _classCallCheck2.default)(this, ReactTextareaAutocomplete);
    _this = _super.call(this, _props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getSelectionPosition", function () {
      if (!_this.textareaRef) return null;
      return {
        selectionStart: _this.textareaRef.selectionStart,
        selectionEnd: _this.textareaRef.selectionEnd
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getSelectedText", function () {
      if (!_this.textareaRef) return null;
      var _this$textareaRef = _this.textareaRef,
          selectionStart = _this$textareaRef.selectionStart,
          selectionEnd = _this$textareaRef.selectionEnd;
      if (selectionStart === selectionEnd) return null;
      return _this.state.value.substr(selectionStart, selectionEnd - selectionStart);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setCaretPosition", function () {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!_this.textareaRef) return;

      _this.textareaRef.focus();

      _this.textareaRef.setSelectionRange(position, position);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getCaretPosition", function () {
      if (!_this.textareaRef) {
        return 0;
      }

      return _this.textareaRef.selectionEnd;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onEnter", function (event) {
      var trigger = _this.state.currentTrigger;

      if (!_this.textareaRef) {
        return;
      }

      var hasFocus = _this.textareaRef.matches(':focus');

      if (!hasFocus || event.shiftKey === true) {
        return;
      }

      if (!trigger) {
        _this._replaceWord();

        if (_this.textareaRef) {
          _this.textareaRef.selectionEnd = 0;
        }

        _this.props.handleSubmit(event);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onSpace", function () {
      if (!_this.props.replaceWord) {
        return;
      }

      if (!_this.textareaRef) {
        return;
      }

      var hasFocus = _this.textareaRef.matches(':focus');

      if (!hasFocus) {
        return;
      }

      _this._replaceWord();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_replaceWord", function () {
      var lastWordRegex = /([^\s]+)(\s*)$/;
      var value = _this.state.value;
      var match = lastWordRegex.exec(value.slice(0, _this.getCaretPosition()));
      var lastWord = match && match[1];

      if (!lastWord) {
        return;
      }

      var spaces = match[2];

      var newWord = _this.props.replaceWord(lastWord);

      if (newWord == null) {
        return;
      }

      var textBeforeWord = value.slice(0, _this.getCaretPosition() - match[0].length);
      var textAfterCaret = value.slice(_this.getCaretPosition(), -1);
      var newText = textBeforeWord + newWord + spaces + textAfterCaret;

      _this.setState({
        value: newText
      }, function () {
        var e = new _customEvent.default('change', {
          bubbles: true
        });

        _this.textareaRef.dispatchEvent(e);

        if (_this.props.onChange) _this.props.onChange(e);
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onSelect", function (newToken) {
      var _this$state = _this.state,
          selectionEnd = _this$state.selectionEnd,
          currentTrigger = _this$state.currentTrigger,
          textareaValue = _this$state.value;
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          trigger = _this$props.trigger;
      if (!currentTrigger) return;

      var computeCaretPosition = function computeCaretPosition(position, token, startToken) {
        switch (position) {
          case 'start':
            return startToken;

          case 'next':
          case 'end':
            return startToken + token.length;

          default:
            if (!Number.isInteger(position)) {
              throw new Error('RTA: caretPosition should be "start", "next", "end" or number.');
            }

            return position;
        }
      };

      var textToModify = textareaValue.slice(0, selectionEnd);
      var startOfTokenPosition = textToModify.search(new RegExp("\\".concat(currentTrigger, "[^\\".concat(currentTrigger).concat(trigger[currentTrigger].allowWhitespace ? '' : '\\s', "]"), "*$")));
      var newTokenString = newToken.caretPosition === 'next' ? "".concat(newToken.text, " ") : newToken.text;
      var newCaretPosition = computeCaretPosition(newToken.caretPosition, newTokenString, startOfTokenPosition);
      var modifiedText = textToModify.substring(0, startOfTokenPosition) + newTokenString;

      _this.setState({
        value: textareaValue.replace(textToModify, modifiedText),
        dataLoading: false
      }, function () {
        var e = new _customEvent.default('change', {
          bubbles: true
        });

        _this.textareaRef.dispatchEvent(e);

        if (onChange) onChange(e);

        _this.setCaretPosition(newCaretPosition);
      });

      _this._closeAutocomplete();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getItemOnSelect", function () {
      var currentTrigger = _this.state.currentTrigger;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) return null;
      var callback = triggerSettings.callback;
      if (!callback) return null;
      return function (item) {
        if (typeof callback !== 'function') {
          throw new Error('Output functor is not defined! You have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
        }

        if (callback) {
          return callback(item, currentTrigger);
        }

        return null;
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getTextToReplace", function () {
      var _this$state2 = _this.state,
          currentTrigger = _this$state2.currentTrigger,
          actualToken = _this$state2.actualToken;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) return null;
      var output = triggerSettings.output;
      return function (item) {
        if (typeof item === 'object' && (!output || typeof output !== 'function')) {
          throw new Error('Output functor is not defined! If you are using items as object you have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
        }

        if (output) {
          var textToReplace = output(item, currentTrigger);

          if (!textToReplace || typeof textToReplace === 'number') {
            throw new Error("Output functor should return string or object in shape {text: string, caretPosition: string | number}.\nGot \"".concat(String(textToReplace), "\". Check the implementation for trigger \"").concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more informations.\n"));
          }

          if (typeof textToReplace === 'string') {
            return {
              text: textToReplace,
              caretPosition: DEFAULT_CARET_POSITION
            };
          }

          if (!textToReplace.text) {
            throw new Error("Output \"text\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"".concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n"));
          }

          if (!textToReplace.caretPosition) {
            throw new Error("Output \"caretPosition\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"".concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n"));
          }

          return textToReplace;
        }

        if (typeof item !== 'string') {
          throw new Error('Output item should be string\n');
        }

        return {
          text: "".concat(currentTrigger).concat(item).concat(currentTrigger),
          caretPosition: DEFAULT_CARET_POSITION
        };
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getCurrentTriggerSettings", function () {
      var currentTrigger = _this.state.currentTrigger;
      if (!currentTrigger) return null;
      return _this.props.trigger[currentTrigger];
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getValuesFromProvider", function () {
      var _this$state3 = _this.state,
          currentTrigger = _this$state3.currentTrigger,
          actualToken = _this$state3.actualToken;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) {
        return;
      }

      var dataProvider = triggerSettings.dataProvider,
          component = triggerSettings.component;

      if (typeof dataProvider !== 'function') {
        throw new Error('Trigger provider has to be a function!');
      }

      _this.setState({
        dataLoading: true
      });

      var providedData = dataProvider(actualToken, _this.state.value);

      if (!(providedData instanceof Promise)) {
        providedData = Promise.resolve(providedData);
      }

      providedData.then(function (data) {
        if (!Array.isArray(data)) {
          throw new Error('Trigger provider has to provide an array!');
        }

        if (typeof component !== 'function') {
          throw new Error('Component should be defined!');
        }

        if (currentTrigger !== _this.state.currentTrigger) return;

        if (!data.length) {
          _this._closeAutocomplete();

          return;
        }

        _this.setState({
          dataLoading: false,
          data,
          component
        });
      }).catch(function (e) {
        return errorMessage(e.message);
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getSuggestions", function () {
      var _this$state4 = _this.state,
          currentTrigger = _this$state4.currentTrigger,
          data = _this$state4.data;
      if (!currentTrigger || !data || data && !data.length) return null;
      return data;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_createRegExp", function () {
      var trigger = _this.props.trigger;
      _this.tokenRegExp = new RegExp("([".concat(Object.keys(trigger).join(''), "])(?:(?!\\1)[^\\s])*$"));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_closeAutocomplete", function () {
      _this.setState({
        data: null,
        dataLoading: false,
        currentTrigger: null,
        top: null,
        left: null
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cleanUpProps", function () {
      var props = _objectSpread({}, _this.props);

      var notSafe = ['loadingComponent', 'containerStyle', 'minChar', 'scrollToItem', 'ref', 'innerRef', 'onChange', 'onCaretPositionChange', 'className', 'value', 'trigger', 'listStyle', 'itemStyle', 'containerStyle', 'loaderStyle', 'className', 'containerClassName', 'listClassName', 'itemClassName', 'loaderClassName', 'closeOnClickOutside', 'dropdownStyle', 'dropdownClassName', 'movePopupAsYouType', 'handleSubmit', 'replaceWord', 'grow', 'additionalTextareaProps'];

      for (var prop in props) {
        if (notSafe.includes(prop)) delete props[prop];
      }

      return props;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_changeHandler", function (e) {
      var _this$props2 = _this.props,
          trigger = _this$props2.trigger,
          onChange = _this$props2.onChange,
          minChar = _this$props2.minChar,
          onCaretPositionChange = _this$props2.onCaretPositionChange,
          movePopupAsYouType = _this$props2.movePopupAsYouType;
      var _this$state5 = _this.state,
          top = _this$state5.top,
          left = _this$state5.left;
      var textarea = e.target;
      var selectionEnd = textarea.selectionEnd,
          selectionStart = textarea.selectionStart;
      var value = textarea.value;

      if (onChange) {
        e.persist();
        onChange(e);
      }

      if (onCaretPositionChange) {
        var caretPosition = _this.getCaretPosition();

        onCaretPositionChange(caretPosition);
      }

      _this.setState({
        value
      });

      var tokenMatch = _this.tokenRegExp.exec(value.slice(0, selectionEnd));

      var lastToken = tokenMatch && tokenMatch[0];
      var currentTrigger = lastToken && Object.keys(trigger).find(function (a) {
        return a === lastToken[0];
      }) || null;

      if ((!lastToken || lastToken.length <= minChar) && (_this.state.currentTrigger && !trigger[_this.state.currentTrigger].allowWhitespace || !_this.state.currentTrigger)) {
        _this._closeAutocomplete();

        return;
      }

      if (currentTrigger && value[tokenMatch.index - 1] && trigger[currentTrigger].afterWhitespace && !value[tokenMatch.index - 1].match(/\s/)) {
        _this._closeAutocomplete();

        return;
      }

      if (_this.state.currentTrigger && trigger[_this.state.currentTrigger].allowWhitespace) {
        tokenMatch = new RegExp("\\".concat(_this.state.currentTrigger, "[^").concat(_this.state.currentTrigger, "]*$")).exec(value.slice(0, selectionEnd));
        lastToken = tokenMatch && tokenMatch[0];

        if (!lastToken) {
          _this._closeAutocomplete();

          return;
        }

        currentTrigger = Object.keys(trigger).find(function (a) {
          return a === lastToken[0];
        }) || null;
      }

      var actualToken = lastToken.slice(1);

      if (!currentTrigger) {
        return;
      }

      if (movePopupAsYouType || top === null && left === null || lastToken.length === 1) {
        var _getCaretCoordinates = (0, _textareaCaret.default)(textarea, selectionEnd),
            newTop = _getCaretCoordinates.top,
            newLeft = _getCaretCoordinates.left;

        _this.setState({
          top: newTop - _this.textareaRef.scrollTop || 0,
          left: newLeft
        });
      }

      _this.setState({
        selectionEnd,
        selectionStart,
        currentTrigger,
        actualToken
      }, function () {
        try {
          _this._getValuesFromProvider();
        } catch (err) {
          errorMessage(err.message);
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_selectHandler", function (e) {
      var _this$props3 = _this.props,
          onCaretPositionChange = _this$props3.onCaretPositionChange,
          onSelect = _this$props3.onSelect;

      if (onCaretPositionChange) {
        var caretPosition = _this.getCaretPosition();

        onCaretPositionChange(caretPosition);
      }

      if (onSelect) {
        e.persist();
        onSelect(e);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onClickAndBlurHandler", function (e) {
      var _this$props4 = _this.props,
          closeOnClickOutside = _this$props4.closeOnClickOutside,
          onBlur = _this$props4.onBlur;
      var el = e.relatedTarget;

      if (_this.dropdownRef && el instanceof Node && _this.dropdownRef.contains(el)) {
        return;
      }

      if (closeOnClickOutside) {
        _this._closeAutocomplete();
      }

      if (onBlur) {
        e.persist();
        onBlur(e);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onScrollHandler", function () {
      _this._closeAutocomplete();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_dropdownScroll", function (item) {
      var scrollToItem = _this.props.scrollToItem;
      if (!scrollToItem) return;

      if (scrollToItem === true) {
        (0, _utils.defaultScrollToItem)(_this.dropdownRef, item);
        return;
      }

      if (typeof scrollToItem !== 'function' || scrollToItem.length !== 2) {
        throw new Error('`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.');
      }

      scrollToItem(_this.dropdownRef, item);
    });
    var _this$props5 = _this.props,
        loadingComponent = _this$props5.loadingComponent,
        _trigger = _this$props5.trigger,
        _value = _this$props5.value;

    _this._createRegExp();

    if (!loadingComponent) {
      throw new Error('RTA: loadingComponent is not defined');
    }

    if (!_trigger) {
      throw new Error('RTA: trigger is not defined');
    }

    _this.state = {
      top: null,
      left: null,
      currentTrigger: null,
      actualToken: '',
      data: null,
      value: _value || '',
      dataLoading: false,
      selectionEnd: 0,
      selectionStart: 0,
      component: null,
      listenerIndex: 0
    };
    return _this;
  }

  (0, _createClass2.default)(ReactTextareaAutocomplete, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      _listener.default.add(_listener.KEY_CODES.ESC, function () {
        return _this2._closeAutocomplete();
      });

      _listener.default.add(_listener.KEY_CODES.SPACE, function () {
        return _this2._onSpace();
      });

      var listenerIndex = _listener.default.add(_listener.KEY_CODES.ENTER, function (e) {
        return _this2._onEnter(e);
      });

      this.setState({
        listenerIndex
      });

      _listener.default.startListen();
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      this._update(nextProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      _listener.default.stopListen();

      _listener.default.remove(this.state.listenerIndex);
    }
  }, {
    key: "_update",
    value: function _update(_ref) {
      var value = _ref.value,
          trigger = _ref.trigger;
      var oldValue = this.state.value;
      var oldTrigger = this.props.trigger;
      if (value !== oldValue || !oldValue) this.setState({
        value
      });

      if (Object.keys(trigger).join('') !== Object.keys(oldTrigger).join('')) {
        this._createRegExp();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props6 = this.props,
          Loader = _this$props6.loadingComponent,
          style = _this$props6.style,
          className = _this$props6.className,
          itemStyle = _this$props6.itemStyle,
          listClassName = _this$props6.listClassName,
          itemClassName = _this$props6.itemClassName,
          dropdownClassName = _this$props6.dropdownClassName,
          dropdownStyle = _this$props6.dropdownStyle,
          containerStyle = _this$props6.containerStyle,
          containerClassName = _this$props6.containerClassName,
          loaderStyle = _this$props6.loaderStyle,
          loaderClassName = _this$props6.loaderClassName;
      var _this$state6 = this.state,
          dataLoading = _this$state6.dataLoading,
          currentTrigger = _this$state6.currentTrigger,
          component = _this$state6.component,
          value = _this$state6.value;

      var suggestionData = this._getSuggestions();

      var textToReplace = this._getTextToReplace();

      var selectedItem = this._getItemOnSelect();

      var maxRows = this.props.maxRows;

      if (!this.props.grow) {
        maxRows = 1;
      }

      return _react.default.createElement("div", {
        className: "rta ".concat(dataLoading === true ? 'rta--loading' : '', " ").concat(containerClassName || ''),
        style: containerStyle
      }, (dataLoading || suggestionData) && currentTrigger && _react.default.createElement("div", {
        ref: function ref(_ref2) {
          _this3.dropdownRef = _ref2;
        },
        style: _objectSpread({}, dropdownStyle),
        className: "rta__autocomplete ".concat(dropdownClassName || '')
      }, suggestionData && component && textToReplace && _react.default.createElement(_List.default, {
        value: value,
        values: suggestionData,
        component: component,
        className: listClassName,
        itemClassName: itemClassName,
        itemStyle: itemStyle,
        getTextToReplace: textToReplace,
        getSelectedItem: selectedItem,
        onSelect: this._onSelect,
        dropdownScroll: this._dropdownScroll
      }), dataLoading && _react.default.createElement("div", {
        className: "rta__loader ".concat(suggestionData !== null ? 'rta__loader--suggestion-data' : 'rta__loader--empty-suggestion-data', " ").concat(loaderClassName || ''),
        style: loaderStyle
      }, _react.default.createElement(Loader, {
        data: suggestionData
      }))), _react.default.createElement(_reactTextareaAutosize.default, (0, _extends2.default)({}, this._cleanUpProps(), {
        inputRef: function inputRef(ref) {
          _this3.props.innerRef && _this3.props.innerRef(ref);
          _this3.textareaRef = ref;
        },
        maxRows: maxRows,
        className: "rta__textarea ".concat(className || ''),
        onChange: this._changeHandler,
        onSelect: this._selectHandler,
        onScroll: this._onScrollHandler,
        onClick: this._onClickAndBlurHandler,
        onBlur: this._onClickAndBlurHandler,
        onFocus: this.props.onFocus,
        value: value,
        style: style
      }, this.props.additionalTextareaProps)));
    }
  }]);
  return ReactTextareaAutocomplete;
}(_react.default.Component);

(0, _defineProperty2.default)(ReactTextareaAutocomplete, "defaultProps", {
  closeOnClickOutside: true,
  movePopupAsYouType: false,
  value: '',
  minChar: 1,
  scrollToItem: true,
  maxRows: 10
});

var triggerPropsCheck = function triggerPropsCheck(_ref3) {
  var trigger = _ref3.trigger;
  if (!trigger) return Error('Invalid prop trigger. Prop missing.');
  var triggers = Object.entries(trigger);

  for (var i = 0; i < triggers.length; i += 1) {
    var _triggers$i = (0, _slicedToArray2.default)(triggers[i], 2),
        triggerChar = _triggers$i[0],
        settings = _triggers$i[1];

    if (typeof triggerChar !== 'string' || triggerChar.length !== 1) {
      return Error('Invalid prop trigger. Keys of the object has to be string / one character.');
    }

    var triggerSetting = settings;
    var component = triggerSetting.component,
        dataProvider = triggerSetting.dataProvider,
        output = triggerSetting.output,
        callback = triggerSetting.callback,
        afterWhitespace = triggerSetting.afterWhitespace,
        allowWhitespace = triggerSetting.allowWhitespace;

    if (!component || typeof component !== 'function') {
      return Error('Invalid prop trigger: component should be defined.');
    }

    if (!dataProvider || typeof dataProvider !== 'function') {
      return Error('Invalid prop trigger: dataProvider should be defined.');
    }

    if (output && typeof output !== 'function') {
      return Error('Invalid prop trigger: output should be a function.');
    }

    if (callback && typeof callback !== 'function') {
      return Error('Invalid prop trigger: callback should be a function.');
    }

    if (afterWhitespace && allowWhitespace) {
      return Error('Invalid prop trigger: afterWhitespace and allowWhitespace can be used together');
    }
  }

  return null;
};

ReactTextareaAutocomplete.propTypes = {
  loadingComponent: _propTypes.default.func.isRequired,
  minChar: _propTypes.default.number,
  onChange: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  onBlur: _propTypes.default.func,
  onCaretPositionChange: _propTypes.default.func,
  className: _propTypes.default.string,
  containerStyle: _propTypes.default.object,
  containerClassName: _propTypes.default.string,
  closeOnClickOutside: _propTypes.default.bool,
  style: _propTypes.default.object,
  listStyle: _propTypes.default.object,
  itemStyle: _propTypes.default.object,
  loaderStyle: _propTypes.default.object,
  dropdownStyle: _propTypes.default.object,
  listClassName: _propTypes.default.string,
  itemClassName: _propTypes.default.string,
  loaderClassName: _propTypes.default.string,
  dropdownClassName: _propTypes.default.string,
  value: _propTypes.default.string,
  trigger: triggerPropsCheck
};
var _default = ReactTextareaAutocomplete;
exports.default = _default;